(function () {
define('api-php',
  ['jquery', 'underscore'],
  function ($, _) {
    
    var API = {
      getAnswerSpaceMap: function () {
        return $.ajax('/_R_/common/3/xhr/GetConfig.php');
      },

      getInteractionResult: function (iact, args, options) {
        var getargs = '';
        if (args && typeof args === "object") {
          _.each(args, function (value, key, list) {
            getargs += '&' + key + '=' + value;
          });
        }
        return $.ajax('/_R_/common/3/xhr/GetAnswer.php?asn=' + window.BMP.siteVars.answerSpace + '&iact=' + iact + '&ajax=false' + getargs, options);
      },

      getForm: function (form) {
        return $.ajax('/_BICv3_/xhr/GetForm.php?asn=' + window.BMP.siteVars.answerSpace + '&form=' + form);
      },

      getDataSuitcase: function (suitcase, time) {
        return $.ajax('/_R_/common/3/xhr/GetMoJO.php?_id=' + window.BMP.siteVars.answerSpaceId + '&_m=' + suitcase + '&_lc=' + time, {dataType: "text"});
      },

      setPendingItem: function (formname, formaction, formdata) {
        return $.post('/_R_/common/3/xhr/SaveFormRecord.php?_asid=' + window.BMP.siteVars.answerSpaceId + '&_fn=' + formname + '&_action=' + formaction, formdata);
      }

    };

    return API;
  }
);
define('data-pouch',
  ['api-php', 'pouchdb', 'jquery', 'underscore'],
  function (API, Pouch, $, _) {
    

    var Data = function (name) {//, apiTrigger, apiCall, apiParameters) {
      if (this.dbAdapter && name) {
        this.name = name;
      } else {
        this.name = 'BlinkMobile';
      }
    };

    _.extend(Data.prototype, {

      dbAdapter: function () {
        var type = false;
        if (window.BMP.isBlinkGap === true && Pouch.adapters.websql) {
          type = 'websql://';
        } else if (Pouch.adapters.idb) {
          type = 'idb://';
        }
        return type;
      },

      create: function (model) {
        var dfrd, db;
        dfrd = new $.Deferred();
        db = new Pouch(this.dbAdapter() + this.name, function (err, db) {
          if (err) {
            dfrd.reject(err);
          } else {
            db.post(model.toJSON(), function (err, response) {
              if (err) {
                dfrd.reject(err);
              } else {
                dfrd.resolve(response);
              }
            });
          }
        });
        return dfrd.promise();
      },


      update: function (model) {
        var dfrd, db, data;
        dfrd = new $.Deferred();
        data = this;
        db = new Pouch(this.dbAdapter() + this.name, function (err, db) {
          if (err) {
            dfrd.reject(err);
          } else {
            db.put(model.toJSON(), function (err, response) {
              if (err) {
                dfrd.reject(err);
              } else {
                //dfrd.resolve(response);
                data.read(model).done(function (doc) {
                  dfrd.resolve(doc);
                });
              }
            });
          }
        });
        return dfrd.promise();
      },

      read: function (model) {
        var dfrd, db, api;
        dfrd = new $.Deferred();
        db = new Pouch(this.dbAdapter() + this.name, function (err, db) {
          if (err) {
            dfrd.reject(err);
          } else {
            db.get(model.id, function (err, doc) {
              if (err) {
                dfrd.reject(err);
              } else {
                dfrd.resolve(doc);
              }
            });
          }
        });
        return dfrd.promise();
      },

      readAll: function () {
        var dfrd, db;
        dfrd = new $.Deferred();
        db = new Pouch(this.dbAdapter() + this.name, function (err, db) {
          if (err) {
            dfrd.reject(err);
          } else {
            db.allDocs({include_docs: true}, function (err, response) {
              if (err) {
                dfrd.reject(err);
              } else {
                dfrd.resolve(_.map(response.rows, function (value, key, list) {
                  return value.doc;
                }));
              }
            });
          }
        });
        return dfrd.promise();
      },

      delete: function (model) {
        var dfrd, db;
        dfrd = new $.Deferred();
        db = new Pouch(this.dbAdapter() + this.name, function (err, db) {
          if (err) {
            dfrd.reject(err);
          } else {
            db.get(model.id, function (err, doc) {
              if (err) {
                dfrd.reject(err);
              } else {
                db.remove(doc, function (err, doc) {
                  if (err) {
                    dfrd.reject(err);
                  } else {
                    dfrd.resolve(doc);
                  }
                });
              }
            });
          }
        });
        return dfrd.promise();
      },

      deleteAll: function (model) {
        var dfrd, db;
        dfrd = new $.Deferred();
        db = new Pouch.destroy(this.name, function (err, info) {
          if (err) {
            dfrd.reject(err);
          } else {
            dfrd.resolve(info);
          }
        });
        return dfrd.promise();
      },

      apiRequest: function (model) {
        var dfrd;
        dfrd = new $.Deferred();
        if (this.apiCall) {
          dfrd = API[this.apiCall].apply(this, _.map(this.apiParameters, function (value, key, list) {
            return model.get(value);
          }));
        } else {
          dfrd.reject('No API call set');
        }
        return dfrd.promise();
      }

    });

    return Data;
  }
);
define('wrapper-backbone',
  ['backbone', 'jquery', 'data-pouch'],
  function (Backbone, $, data) {
    

    // Save traditional sync method as ajaxSync
    Backbone.ajaxSync = Backbone.sync;

    // Fallback to traditional sync when not specified
    Backbone.getSyncMethod = function (model) {
      if (model.data || (model.collection && model.collection.data)) {
        return Backbone.dataSync;
      } else {
        return Backbone.ajaxSync;
      }
    };

    Backbone.dataSync = function (method, model, options) {
      var data, dfrd, promise, persist;
      data = model.data || model.collection.data;
      dfrd = new $.Deferred();
      promise = dfrd.promise();

      // persist = function () {
      switch (method) {
      case "read":
        //promise = model.id !== undefined ? data.read(model) : data.readAll();
        promise = model.id !== undefined ? data.read(model) : data.readAll();
        break;
      case "create":
        promise = data.create(model);
        break;
      case "update":
        promise = data.update(model);
        break;
      case "patch":
        promise = data.update(model);
        break;
      case "delete":
        promise = data.delete(model);
        break;
      }

      promise.then(function (response) {
        if (options.success) {
          options.success(response);
        }
      }, function (response) {
        if (options.error) {
          options.error(response);
        }
      });

      model.trigger('request', model, promise, options);

        // return promise;
      // };

      // if (data.apiTrigger && data.apiTrigger === method) {
      //   data.read(model).then(function (response) {
      //     model.set(response, options);
      //     data.apiRequest(model).then(function (resp) {
      //       model.set(model.parse(resp, options), options);
      //       persist();
      //     });
      //   }, function (err) {
      //     data.apiRequest(model).then(function (resp) {
      //       model.set(model.parse(resp, options), options);
      //       persist();
      //     });
      //   });
      // } else {
      //   persist();
      // }

      return promise;
    };

    // Hook Backbone.sync up to the data layer
    Backbone.sync = function (method, model, options) {
      return Backbone.getSyncMethod(model).apply(this, [method, model, options]);
    };

    return Backbone;
  }
);

        // if (this.db === false) {
        //   // No DB mode
        //   promise = new $.Deferred().resolve().promise();
        // } else {
        //   // DB mode
        //   promise = new $.Deferred().resolve().promise();
        // };
define('model-interaction-mobile',
  ['wrapper-backbone', 'jquery', 'underscore', 'api-php', 'jquerymobile'],
  function (Backbone, $, _, API) {
    
    var Interaction = Backbone.Model.extend({

      idAttribute: "_id",

      defaults: {
        header: null,
        content: null,
        contentTime: null,
        footer: null,
        name: null
      },

      inherit: function (config) {
        if (this.has("parent")) {
          var app = require('model-application-mobile'),
            parent;

          _.each(this.attributes, function (value, key, list) {
            if (!_.has(config, key) || !config[key]) {
              config[key] = value;
            }
          }, this);

          if (this.get("parent") !== "app") {
            // Not the answerSpace config, so go deeper
            parent = app.interactions.get(this.get("parent"));
            parent.inherit(config);
          } else {
            _.each(app.attributes, function (value, key, list) {
              if (!_.has(config, key) || !config[key]) {
                config[key] = value;
              }
            }, app);
          }
        }
        return config;
      },

      performXSLT: function () {
        var xsl,
          xmlString,
          xslString,
          html,
          xml,
          processor,
          transformer,
          args,
          placeholders,
          pLength,
          p,
          value,
          model,
          starType,
          condition,
          variable;

        if (this.has("args")) {
          args = this.get("args");
          placeholders = xsl.match(/\$args\[[\w\:][\w\:\-\.]*\]/g);
          pLength = placeholders ? placeholders.length : 0;
          xsl = this.get("xsl");
          for (p = 0; p < pLength; p = p + 1) {
            value = typeof args[placeholders[p].substring(1)] === 'string' ? args[placeholders[p].substring(1)] : '';
            // TODO: find a better solution upstream for having to decode this here
            value = value.replace('"', '');
            value = value.replace("'", '');
            value = decodeURIComponent(value);
            xsl = xsl.replace(placeholders[p], value);
          }
        } else {
          xsl = this.get("xsl");
        }

        starType = xsl.match(/blink-stars\(([@\w.]+),\W*(\w+)\W*\)/);
        if (starType) {
          require(['model-application-mobile'], function (app) {
            while (starType) {
              condition = '';
              variable = starType[1];
              starType = starType[2];

              _.each(app.stars.where({type: starType}), function (value, key, list) {
                condition += ' or ' + variable + '=\'' + value.get("_id") + '\'';
              });
              condition = condition.substr(4);

              if (condition.length > 0) {
                xsl = xsl.replace(/\(?blink-stars\(([@\w.]+),\W*(\w+)\W*\)\)?/, '(' + condition + ')');
              } else {
                xsl = xsl.replace(/\(?blink-stars\(([@\w.]+),\W*(\w+)\W*\)\)?/, '(false())');
              }

              starType = xsl.match(/blink-stars\(([@\w.]+),\W*(\w+)\W*\)/);
            }
          });
        }

        model = this;
        require(['model-application-mobile'], function (app) {
          xmlString = model.get("starXml") ? model.get("starXml") : app.datasuitcases.get(model.get("xml")).get("data");
          xslString = xsl;
          if (typeof xmlString !== 'string' || typeof xslString !== 'string') {
            model.set("content", 'XSLT failed due to poorly formed XML or XSL.');
            return;
          }
          xml = $.parseXML(xmlString);
          xsl = $.parseXML(xslString);
          if (window.XSLTProcessor) {
            //console.log("XSLTProcessor (W3C)");
            processor = new window.XSLTProcessor();
            processor.importStylesheet(xsl);
            html = processor.transformToFragment(xml, document);
          } else if (xml.transformNode !== undefined) {
            //console.log("transformNode (IE)");
            html = xml.transformNode(xsl);
          } else if (window.xsltProcess) {
            //console.log("AJAXSLT");
            html = window.xsltProcess(xml, xsl);
          } else {
            //console.log("XSLT: Not supported");
            html = '<p>Your browser does not support Data Suitcase keywords.</p>';
          }
          if (html) {
            model.set("content", html);
          }
        });
      },

      prepareView: function (data) {
        // Handle MADL updates here
        // Check for other updates needed here?
        var dfrd = new $.Deferred(),
          model = this,
          homeInteraction,
          childInteraction,
          xml = '',
          attrs;

        if (model.id === window.BMP.siteVars.answerSpace) {
          require(['model-application-mobile'], function (app) {
            if (app.has("homeScreen") && app.get("homeScreen") !== false && app.has("homeInteraction")) {
              homeInteraction = app.interactions.findWhere({dbid: "i" + app.get("homeInteraction")});
              if (homeInteraction) {
                homeInteraction.set({parent: model.get("parent")});
              }

              childInteraction = app.interactions.findWhere({dbid: "a" + window.BMP.siteVars.answerSpace});
              if (childInteraction) {
                childInteraction.set({parent: model.id});
              }

              homeInteraction.prepareView().done(function () {
                dfrd.resolve(homeInteraction);
              });
            } else {
              dfrd.resolve(model);
            }
          });
        }

        if (model.get("type") === "madl code") {
          API.getInteractionResult(model.id, this.get('args'), data.options).then(
            function (data, textStatus, jqXHR) {
              model.save({
                content: data,
                contentTime: Date.now()
              }, {
                success: function () {
                  dfrd.resolve(model);
                },
                error: function (error) {
                  dfrd.reject(error);
                }
              });
            },
            function (jqXHR, textStatus, errorThrown) {
              dfrd.reject(errorThrown);
            }
          );
        }

        if (model.get("type") === "xslt" && model.get("xml").indexOf('stars:') === 0) {
          model.set({
            mojoType: "stars",
            xml: model.get("xml").replace(/^stars:/, '')
          });
        }

        if (model.get("type") === "xslt" && model.get("mojoType") === "stars") {
          require(['model-application-mobile'], function (app) {
            _.each(app.stars.where({type: model.get("xml")}), function (value, key, list) {
              xml += '<' + value.get("type") + ' id="' + value.get("_id") + '">';

              attrs = _.clone(value.attributes);
              delete attrs._id;
              delete attrs._rev;
              delete attrs.type;
              delete attrs.state;

              _.each(attrs, function (value, key, list) {
                xml += '<' + key + '>' + value + '</' + key + '>';
              });

              xml += '</' + value.get("type") + '>';
            });
            xml = '<stars>' + xml + '</stars>';
            model.set({
              starXml: xml
            });
            dfrd.resolve(model);
          });
        }

        if (model.get("type") !== "madl code" && model.id !== window.BMP.siteVars.answerSpace) {
          dfrd.resolve(model);
        }

        return dfrd.promise();
      },

      parseArgs: function (argString) {
        var args = argString.split('&'),
          tempargs,
          finalargs = {};

        _.each(args, function (element, index, list) {
          tempargs = element.split('=');
          if (tempargs[0].substr(0, 4) !== "args") {
            tempargs[0] = "args[" + tempargs[0] + "]";
          }
          finalargs[tempargs[0]] = tempargs[1];
        });

        if (finalargs) {
          this.set({args: finalargs});
        } else {
          this.set({args: null});
        }

        return this;
      }
    });

    return Interaction;
  }
);

define('collection-interactions-mobile',
  ['wrapper-backbone', 'model-interaction-mobile', 'data-pouch', 'underscore'],
  function (Backbone, Interaction, Data, _) {
    
    var InteractionCollection = Backbone.Collection.extend({

      model: Interaction,

      initialize: function () {
        var collection = this;
        collection.data = new Data(window.BMP.siteVars.answerSpace + '-Interaction');
        collection.fetch({
          success: function () {
            collection.trigger("initialize");
          },
          error: function () {
            collection.trigger("initialize");
          }
        });
      },

      save: function () {
        _.each(this.models, function (model, key, list) {
          model.save();
        });
      }

    });

    return InteractionCollection;
  }
);
define('model-datasuitcase-mobile',
  ['wrapper-backbone', 'api-php'],
  function (Backbone, API) {
    
    var DataSuitcase = Backbone.Model.extend({
      idAttribute: "_id",

      populate: function () {
        var model = this,
          time = 0;

        if (this.has("contentTime")) {
          time = this.get("contentTime");
        }

        API.getDataSuitcase(this.id, time).then(
          function (data, textStatus, jqXHR) {
            model.save({
              data: data,
              contentTime: Date.now()
            });
          },
          function (jqXHR, textStatus, errorThrown) {
            console.log(errorThrown);
          }
        );
      }
    });
    return DataSuitcase;
  }
);

define('collection-datasuitcases-mobile',
  ['wrapper-backbone', 'model-datasuitcase-mobile', 'data-pouch'],
  function (Backbone, DataSuitcase, Data) {
    
    var DataSuitcaseCollection = Backbone.Collection.extend({
      model: DataSuitcase,

      initialize: function () {
        var collection = this;
        collection.data = new Data(window.BMP.siteVars.answerSpace + '-DataSuitcase');
        collection.fetch({
          success: function () {
            collection.trigger("initialize");
          },
          error: function () {
            collection.trigger("initialize");
          }
        });
      }
    });
    return DataSuitcaseCollection;
  }
);

define('model-form-mobile',
  ['wrapper-backbone', 'BlinkForms', 'underscore', 'jquery', 'model-application-mobile', 'api-php'],
  function (Backbone, BlinkForms, _, $, app, API) {
    
    var Form = Backbone.Model.extend({
      idAttribute: "_id",

      populate: function () {
        var model = this;
        API.getForm(this.id).then(
          function (data, textStatus, jqXHR) {
            model.save({
              definition: data.definition,
              contentTime: Date.now()
            });
          },
          function (jqXHR, textStatus, errorThrown) {
            console.log(errorThrown);
          }
        );
      }
    });

    return Form;
  }
);

define('collection-forms-mobile',
  ['wrapper-backbone', 'model-form-mobile', 'BlinkForms', 'jquery', 'underscore', 'data-pouch'],
  function (Backbone, Form, BlinkForms, $, _, Data) {
    
    var FormCollection = Backbone.Collection.extend({
      model: Form,

      initialize: function () {
        var collection = this;
        collection.data = new Data(window.BMP.siteVars.answerSpace + '-Form');
        collection.fetch({
          success: function () {
            collection.trigger("initialize");
          },
          error: function () {
            collection.trigger("initialize");
          }
        });

        BlinkForms.getDefinition = function (name, action) {
          var dfrd = new $.Deferred();
          require(['model-application-mobile'], function (app) {
            var def = app.forms.get(name).get('definition'),
              collapsed,
              elements,
              elNames,
              collapseAction = function (d) {
                var attrs = d.default || {};
                if (action && d[action]) {
                  _.extend(attrs, d[action]);
                }
                return attrs;
              };

            // This is a safety feature, like goggles on a paintball range
            // If you take your mask off, your going to have a bad time
            def = JSON.parse(JSON.stringify(def));

            if (_.isArray(def.default._elements)) {
              def.default._elements = _.map(def.default._elements, collapseAction);
            }
            if (_.isArray(def.default._sections)) {
              def.default._sections = _.map(def.default._sections, collapseAction);
            }
            if (_.isArray(def.default._pages)) {
              def.default._pages = _.map(def.default._pages, collapseAction);
            }

            if (!action) {
              dfrd.resolve(def.default);
            }

            if (def[action] && def[action]._elements) {
              elements = def.default._elements;
              delete def.default._elements;
              elNames = def[action]._elements;
              delete def[action]._elements;
              _.extend(def.default, def[action]);

              // remove all elements not needed for this action
              elements = _.filter(elements, function (el) {
                return elNames.indexOf(el.name) !== -1;
              });
              // sort elements as per the action-specific order
              elements = _.sortBy(elements, function (el) {
                return elNames.indexOf(el.name);
              });

              def.default._elements = elements;
            }
            dfrd.resolve(def.default);
          });
          return dfrd.promise();
        };
      }
    });
    return FormCollection;
  }
);

define('model-pending-mobile',
  ['wrapper-backbone'],
  function (Backbone) {
    
    var PendingItem = Backbone.Model.extend({
      idAttribute: "_id"
    });

    return PendingItem;
  }
);

define('collection-pending',
  ['wrapper-backbone', 'model-pending-mobile', 'data-pouch', 'underscore', 'api-php'],
  function (Backbone, PendingItem, Data, _, API) {
    
    var PendingCollection = Backbone.Collection.extend({
      model: PendingItem,

      initialize: function () {
        var collection = this;
        collection.data = new Data(window.BMP.siteVars.answerSpace + '-Pending');
        collection.fetch({
          success: function () {
            collection.trigger("initialize");
          },
          error: function () {
            collection.trigger("initialize");
          }
        });
      },

      processQueue: function () {
        _.each(this.where({status: "Pending"}), function (element, index, list) {
          API.setPendingItem(element.get('name'), element.get('action'), element.get('data')).done(
            function (data, textStatus, jqXHR) {
              element.destroy({wait: true});
            }
          );
        }, this);
      }
    });

    return PendingCollection;
  }
);
define('model-star-mobile',
  ['wrapper-backbone'],
  function (Backbone) {
    
    var Star = Backbone.Model.extend({
      idAttribute: "_id",

      initialize: function () {
        this.on('add', function () {
          this.save();
        }, this);
      },

      toggle: function () {
        var model = this;
        model.get("state") ? this.set("state", false) : this.set("state", true);
        require(['model-application-mobile'], function (app) {
          if (model.get("state")) {
            app.stars.add(model);
          } else {
            model.destroy();
          }
        });
      }
    });

    return Star;
  }
);

define('collection-stars-mobile',
  ['wrapper-backbone', 'model-star-mobile', 'jquery', 'underscore', 'data-pouch'],
  function (Backbone, Star, $, _, Data) {
    
    var FormCollection = Backbone.Collection.extend({
      model: Star,

      initialize: function () {
        var collection = this;
        collection.data = new Data(window.BMP.siteVars.answerSpace + '-Star');
        collection.fetch({
          success: function () {
            collection.trigger("initialize");
          },
          error: function () {
            collection.trigger("initialize");
          }
        });
      },

      clear: function (type) {
        _.each(this.where({type: type}), function (model) {
          model.destroy();
        });
      }
    });
    return FormCollection;
  }
);

define('model-application-mobile',
  ['wrapper-backbone', 'collection-interactions-mobile', 'collection-datasuitcases-mobile', 'model-datasuitcase-mobile', 'collection-forms-mobile', 'model-form-mobile', 'underscore', 'collection-pending', 'data-pouch', 'api-php', 'jquery', 'collection-stars-mobile'],
  function (Backbone, InteractionCollection, DataSuitcaseCollection, DataSuitcase, FormCollection, Form, _, PendingCollection, Data, API, $, StarsCollection) {
    
    var Application = Backbone.Model.extend({

      initialize: function () {
        var app = this,
          promises = [],
          interactions = new $.Deferred(),
          datasuitcases = new $.Deferred(),
          forms = new $.Deferred(),
          pending = new $.Deferred(),
          stars = new $.Deferred();

        promises.push(interactions.promise(), datasuitcases.promise(), forms.promise(), pending.promise(), stars.promise());

        this.on('change', this.update);

        this.data = new Data(window.BMP.siteVars.answerSpace + '-AnswerSpace');

        this.interactions = new InteractionCollection().once('initialize', function () {
          interactions.resolve();
        });

        this.datasuitcases = new DataSuitcaseCollection().once('initialize', function () {
          datasuitcases.resolve();
        });

        this.forms = new FormCollection().once('initialize', function () {
          forms.resolve();
        });

        this.pending = new PendingCollection().once('initialize', function () {
          pending.resolve();
        });

        this.stars = new StarsCollection().once('initialize', function () {
          stars.resolve();
        });

        $.when.apply($, promises).then(function () {
          app.trigger("initialize");
        });
      },

      idAttribute: "_id",

      populate: function () {
        var app = this,
          dfrd = new $.Deferred(),
          promise = dfrd.promise();

        API.getAnswerSpaceMap().then(
          function (data, textStatus, jqXHR) {
            var models = [];
            _.each(data, function (value, key, list) {
              var model;
              if (key.substr(0, 1) === 'c' || key.substr(0, 1) === 'i') {
                model = value.pertinent;
                model._id = model.name;
                model.dbid = key;
                models.push(model);
              }
              if (key.substr(0, 1) === 'a') {
                model = {
                  _id: window.BMP.siteVars.answerSpace,
                  dbid: key
                };
                models.push(model);

                app.save(value.pertinent);
              }
            }, app);

            app.interactions.set(models).save();
            _.each(_.compact(_.uniq(app.interactions.pluck('xml'))), function (element, index, list) {
              if (!app.datasuitcases.get(element)) {
                app.datasuitcases.create({_id: element}, {success: function (model, resp, options) {
                  model.populate();
                }});
              }
            });

            _.each(_.compact(_.uniq(app.interactions.pluck('blinkFormObjectName'))), function (element, index, list) {
              if (!app.forms.get(element)) {
                app.forms.create({_id: element}, {success: function (model, resp, options) {
                  model.populate();
                }});
              }
            });
            app.trigger("initialize");
            dfrd.resolve();
          },
          function (jqXHR, textStatus, errorThrown) {
            dfrd.reject();
          }
        );
        return promise;
      }
    }),
      app;

    app = new Application();

    return app;
  }
);

/**
 * @license RequireJS text 2.0.3 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
  define: false, window: false, process: false, Packages: false,
  java: false, location: false */

define('text',['module'], function (module) {
    

    var text, fs,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = [],
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.3',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var strip = false, index = name.indexOf("."),
                modName = name.substring(0, index),
                ext = name.substring(index + 1, name.length);

            index = ext.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = ext.substring(index + 1, ext.length);
                strip = strip === "strip";
                ext = ext.substring(0, index);
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName + '.' + parsed.ext,
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                nonStripName = parsed.moduleName + '.' + parsed.ext,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + '.' +
                                     parsed.ext) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node)) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback) {
            var file = fs.readFileSync(url, 'utf8');
            //Remove BOM (Byte Mark Order) from utf8 files if it is there.
            if (file.indexOf('\uFEFF') === 0) {
                file = file.substring(1);
            }
            callback(file);
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback) {
            var xhr = text.createXhr();
            xhr.open('GET', url, true);

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                stringBuffer.append(line);

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    }

    return text;
});

define('text!template-interaction.mustache',[],function () { return '{{{header}}}\n<div data-role="content">\n    {{{content}}}\n</div>\n{{{footer}}}';});

define('text!template-inputPrompt.mustache',[],function () { return '<form method="get">\n    {{{inputs}}}\n    <button type="submit" data-theme="a">Go</button>\n</form>\n';});

define('text!template-form.mustache',[],function () { return '<div id="FormContainer"></div>\n<div id="FormControls" class="ui-grid-b">\n  <div class="ui-block-a">\n    <a id="save" data-role="button" data-icon="edit" data-iconpos="top">Save</a>\n  </div>\n  <div class="ui-block-b">\n    <a id="cancel" data-role="button" data-icon="delete" data-iconpos="top">Cancel</a>\n  </div>\n  <div class="ui-block-c">\n    <a id="submit" data-role="button" data-icon="check" data-iconpos="top">Submit</a>\n  </div>\n</div>\n<div id="FormQueue" class="ui-grid-solo">\n  <div class="ui-block-a">\n    <a id="queue" data-role="button">Pending Queue</a>\n  </div>\n</div>\n\n<div id="cancelPopup" data-role="popup" data-dismissible="false" data-overlay-theme="a" data-theme="c">\n  <div data-role="header">\n    <h1>Cancel Form</h1>\n  </div>\n  <div data-role="content">\n    <h3>Are you sure you want to cancel this form?</h3>\n    <p>This will delete anything you have entered into this form and cannot be undone.</p>\n    <div class="ui-grid-a">\n      <div class="ui-block-a">\n        <a href="#" data-role="button" data-rel="back">Keep Form</a>\n      </div>\n      <div class="ui-block-b">\n        <a href="#" data-role="button">Delete Form</a>\n      </div>\n    </div>\n  </div>\n</div>\n\n\n<div id="pendingPopup" data-role="popup">\n  <div data-role="header">\n    <h1>Pending Queue</h1>\n  </div>\n  <div id="pendingContent" data-role="content">\n  </div>\n</div>\n';});

define('view-interaction-mobile',
  ['jquery', 'wrapper-backbone', 'mustache', 'text!template-interaction.mustache', 'text!template-inputPrompt.mustache', 'text!template-form.mustache', 'model-application-mobile', 'underscore', 'BlinkForms', 'jquerymobile'],
  function ($, Backbone, Mustache, Template, inputPromptTemplate, formTemplate, app, _, BlinkForms) {
    
    var InteractionView = Backbone.View.extend({

      initialize: function () {
        $('body').append(this.$el);

        // this.$el.once("pageremove", function () {
        //   console.log("Backbone view cleanup");

        // })
      },

      events: {
        // Old Blink Link Shortcut Methods
        "click [keyword]" : "blinklink",
        "click [interaction]" : "blinklink",
        "click [category]" : "blinklink",
        "click [masterCategory]" : "blinklink",
        "click [back]" : "back",
        "click [home]" : "blinklink",
        "click [login]" : "blinklink",

        // Form Actions
        "click #FormControls #submit" : "formSubmit",
        "click #FormControls #cancel" : "formCancel",
        "click #FormControls #save" : "formSave",
        "click #queue" : "pendingQueue",

        // Destroy
        "pageremove" : "destroy"
      },

      attributes: {
        "data-role": "page"
      },

      blinklink: function (e) {
        e.preventDefault();

        var $element,
          location,
          attributes = "",
          first = true,
          count,
          path;

        if (e.target.tagName !== 'A') {
          $element = $(e.target).parents('a');
        } else {
          $element = $(e.target);
        }

        location = "";
        if ($element.attr("keyword")) {
          location = $element.attr("keyword");
        } else if ($element.attr("interaction")) {
          location = $element.attr("interaction");
        } else if ($element.attr("category")) {
          location = $element.attr("category");
        } else if ($element.attr("masterCategory")) {
          location = $element.attr("masterCategory");
        } else if ($element.attr("home") === "") {
          location = app.get("siteName");
        } else if ($element.attr("login") === "") {
          if (app.has("loginAccess") && app.has("loginUseInteractions") && app.has("loginUseInteractions") && app.has("loginPromptInteraction")) {
            location = app.get("loginPromptInteraction");
          } else {
            location = app.get("siteName");
          }
        }

        for (count = 0; count < $element[0].attributes.length; count = count + 1) {
          if ($element[0].attributes[count].name.substr(0, 1) === "_") {
            if (!first) {
              attributes += "&args[" + $element[0].attributes[count].name.substr(1) + "]=" + $element[0].attributes[count].value;
            } else {
              first = false;
              attributes = "/?args[" + $element[0].attributes[count].name.substr(1) + "]=" + $element[0].attributes[count].value;
            }
          }
        }

        path = $.mobile.path.parseLocation().pathname;
        if ($.mobile.path.parseLocation().search) {
          path = $.mobile.path.parseLocation().pathname.substr(0, $.mobile.path.parseLocation().pathname.length - 1);
        }

        if (path.slice(-1) === "/") {
          path = path.slice(0, path.length - 1);
        }

        $.mobile.changePage(path + '/' + location + attributes);
      },

      back: function (e) {
        e.preventDefault();
        history.back();
      },

      render: function (data) {
        var form,
          rawform,
          inheritedAttributes = this.model.inherit({}),
          formobject,
          formmodel,
          view = this;

        // Non-type specific
        if (_.has(inheritedAttributes, "themeSwatch")) {
          this.$el.attr("data-theme", inheritedAttributes.themeSwatch);
        }

        // Input Prompt
        if (this.model.has("inputPrompt") && !(this.model.has("args"))) {
          rawform = this.model.get("inputPrompt");
          if (rawform.substr(0, 6) === "<form>") {
            form = rawform;
          } else {
            form = Mustache.render(inputPromptTemplate, {inputs: rawform});
          }
          this.$el.html(Mustache.render(Template, {
            header: inheritedAttributes.header,
            footer: inheritedAttributes.footer,
            content: form
          }));
          this.trigger("render");
        } else if (this.model.has("type") && this.model.get("type") === "xslt") {
          // XSLT
          this.model.once("change:content", function () {
            if (typeof (view.model.get("content")) === 'object') {
              view.$el.html(Mustache.render(Template, {
                header: inheritedAttributes.header,
                footer: inheritedAttributes.footer,
                content: ''
              }));
              view.$el.children('[data-role=content]')[0].appendChild(view.model.get("content"));
              view.processStars();
              view.trigger("render");
            }
          });
          this.model.performXSLT();
        } else if (this.model.has("type") && this.model.get("type") === "form") {
          // Form
          this.$el.html(Mustache.render(Template, {
            header: inheritedAttributes.header,
            footer: inheritedAttributes.footer,
            content: formTemplate
          }));

          BlinkForms.getDefinition(this.model.get("blinkFormObjectName"), this.model.get("blinkFormAction")).then(function (definition) {
            BlinkForms.initialize(definition);
            $('#FormContainer').append(BlinkForms.currentFormObject.$form);
            $('#FormContainer').trigger('create');
          });

          this.trigger("render");
        } else if (this.model.id.toLowerCase() === window.BMP.siteVars.answerSpace.toLowerCase()) {
          require(['text!template-category-list.mustache'], function (categoryTemplate) {
            view.$el.html(Mustache.render(Template, {
              header: inheritedAttributes.header,
              footer: inheritedAttributes.footer,
              content: Mustache.render(categoryTemplate, {
                models: _.map(_.filter(app.interactions.models, function (value, key, list) {
                  return value.id !== window.BMP.siteVars.answerSpace && (value.has("tags") && value.get("tags").length === 0 && value.get("display") !== "hide" || _.filter(value.get("tags"), function (element, index, list) {
                    return element === 'nav-' + window.BMP.siteVars.answerSpace.toLowerCase();
                  }, this).length > 0);
                }, this), function (value, key, list) {
                  return value.attributes;
                }),
                path: data.dataUrl
              })
            }));
            view.trigger("render");
          });
        } else if (!this.model.has("type")) {
          // Category
          require(['text!template-category-list.mustache'], function (categoryTemplate) {
            view.$el.html(Mustache.render(Template, {
              header: inheritedAttributes.header,
              footer: inheritedAttributes.footer,
              content: Mustache.render(categoryTemplate, {
                models: _.map(_.filter(app.interactions.models, function (value, key, list) {
                  return value.get("display") !== "hide" && _.filter(value.get("tags"), function (element, index, list) {
                    return element === 'nav-' + this.model.id.toLowerCase();
                  }, this).length > 0;
                }, view), function (value, key, list) {
                  return value.attributes;
                }),
                path: data.dataUrl
              })
            }));
            view.trigger("render");
          });
        } else if (this.model.get("type") === "message") {
          this.$el.html(Mustache.render(Template, {
            header: inheritedAttributes.header,
            footer: inheritedAttributes.footer,
            content: inheritedAttributes.message
          }));
          this.trigger("render");
        } else {
          this.$el.html(Mustache.render(Template, inheritedAttributes));
          if (this.model.has("content")) {
            this.blinkAnswerMessages();
            this.maps();
            this.processStars();
          }
          this.trigger("render");
        }
        return this;
      },

      maps: function () {
        var mapdiv = this.$el.find("[class=googlemap]");
        if (mapdiv.length !== 0) {
          this.$el.append('<style type="text/css">.googlemap { width: 100%; height: 360px; }</style>');
          this.$el.append('<script src="/_BICv3_/js/gMaps.js"></script>');
        }
      },

      blinkAnswerMessages: function (message) {
        if (!message) {
          // First Pass - Extract content
          var blinkAnswerMessage = this.model.get('content').match(/<!-- blinkAnswerMessage:\{.*\} -->/g);

          if ($.type(blinkAnswerMessage) === 'array') {
            _.each(blinkAnswerMessage, function (element, index, list) {
              this.blinkAnswerMessages(element.substring(24, element.length - 4));
            }, this);
          }
        } else {
          // Process a given message
          message = JSON.parse(message);
          if (typeof message.mojotarget === 'string') {
            if (typeof message.mojoxml === 'string') {
              // Add a DS
              app.datasuitcases.create({
                _id: message.mojotarget,
                data: message.mojoxml
              });
            } else if (message.mojodelete !== undefined) {
              // Remove a DS
              app.datasuitcases.remove(message.mojotarget);
            }
          }

          if (message.startype) {
            if (message.clearstars) {
              // Clear all stars?
              app.stars.clear(message.startype);
            }
            if ($.type(message.staroff) === 'array') {
              // Remove specific stars
              _.each(message.staroff, function (element, index, list) {
                if (app.stars.get(element)) {
                  app.stars.get(element.toString()).destroy();
                }
              }, this);
            }
            if ($.type(message.staron) === 'array') {
              // Add stars
              require(['model-star-mobile'], function (StarModel) {
                _.each(message.staron, function (element, index, list) {
                  app.stars.create({
                    _id: element.toString(),
                    type: message.startype,
                    state: true
                  });
                });
              });
            }
          }
        }
      },

      formSubmit: function () {
        // Put in pending queue for processing
        var view = this;
        BlinkForms.currentFormObject.data().then(function (data) {
          app.pending.create({
            type: "Form",
            status: "Pending",
            name: view.model.get("blinkFormObjectName"),
            action: view.model.get("blinkFormAction"),
            answerspaceid: app.get("dbid"),
            data: data//JSON.stringify(data)
          });
          app.pending.processQueue();
        });
      },

      formCancel: function () {
        // If in pending queue, remove
        // Close the form
        $('#cancelPopup').popup('open');
      },

      formSave: function () {
        // Save to pending queue as a draft
        var view = this;
        BlinkForms.currentFormObject.data().then(function (data) {
          app.pending.create({
            type: "Form",
            status: "Draft",
            name: view.model.get("blinkFormObjectName"),
            action: view.model.get("blinkFormAction"),
            answerspaceid: app.get("dbid"),
            data: JSON.stringify(data)
          });
          app.pending.processQueue();
        });
      },

      pendingQueue: function () {
        require(['text!template-pending-mobile.mustache'], function (Template) {
          var el = $('#pendingContent');
          el.html(Mustache.render(Template, {
            pending: _.map(app.pending.where({status: 'Pending'}), function (model) {return _.clone(model.attributes); }),
            draft: _.map(app.pending.where({status: 'Draft'}), function (model) {return _.clone(model.attributes); })
          }));
          $('#pendingPopup').popup('open');
        });
      },

      destroy: function () {
        this.remove();
      },

      processStars: function () {
        var elements = this.$el.find('.blink-starrable');
        if (elements) {
          require(['view-star-mobile', 'model-star-mobile'], function (StarView, StarModel) {
            elements.each(function (index, element) {
              var view,
                attrs,
                model = app.stars.get($(element).data('id'));
              if (!model) {
                attrs = $(element).data();
                attrs._id = attrs.id.toString();
                delete attrs.id;
                attrs.state = false;
                model = new StarModel(attrs);
              }
              view = new StarView({
                model: model,
                el: element
              });
            });
          });
        }
      }

    });

    return InteractionView;
  }
);

define('router-mobile',
  ['wrapper-backbone', 'model-application-mobile', 'model-interaction-mobile', 'view-interaction-mobile', 'jquery', 'underscore', 'jquerymobile'],
  function (Backbone, app, InteractionModel, InteractionView, $, _) {
    
    var Router = Backbone.Router.extend({
      initialize: function () {
        app.router = this;
        $(document).on('pagebeforeload', function (e, data) {
          e.preventDefault();
          $.mobile.loading('show');
          var path = $.mobile.path.parseUrl(data.dataUrl);

          app.router.inheritanceChain(path.hrefNoSearch).parseArgs(path.search.substr(1)).prepareView(data).then(function (model, response, options) {
            var view = new InteractionView({
              tagName: 'div',
              model: model
            }).once("render", function () {
              this.$el.attr("data-url", data.dataUrl);
              this.$el.attr("data-external-page", true);
              this.$el.one('pagecreate', $.mobile._bindPageRemove);
              data.deferred.resolve(data.absUrl, data.options, this.$el);
            }).render(data);
          }, function (model, xhr, options) {
            data.deferred.reject(data.absUrl, data.options);
            $.mobile.showPageLoadingMsg($.mobile.pageLoadErrorMessageTheme, $.mobile.pageLoadErrorMessage, true);
            setTimeout($.mobile.hidePageLoadingMsg, 1500);
          });
        });
      },

      inheritanceChain: function (data) {
        var path, parent, usedPathItems;
        path = data.substr(1).split('/');
        parent = "app";
        usedPathItems = [];

        if (path[path.length - 1] === "") {
          path.pop();
        }

        _.each(path, function (element, index, list) {
          if (!_.find(usedPathItems, function (id) {return id === element;})) {
            parent = app.interactions.get(element).set({parent: parent}).id;
            usedPathItems.push(element);
          }
        }, this);

        return app.interactions.get(parent);
      }
    });

    return new Router();
  }
);


/*global cordova: true*/
requirejs.config({
  baseUrl: '/_BICv3_/scripts',
  paths: {
    BlinkForms: ['/_BICv3_/js/BlinkForms-jQueryMobile.min'],
    pouchdb: ['/_BICv3_/js/pouchdb-nightly']
  },
  shim: {
    'BlinkForms': {
      exports: 'BlinkForms'
    },
    'pouchdb': {
      exports: 'Pouch'
    }
  }
});

define('main',
  ['wrapper-backbone', 'router-mobile', 'model-interaction-mobile', 'view-interaction-mobile', 'jquery', 'jquerymobile'],
  function (Backbone, router, InteractionModel, InteractionView, $) {
    

    function initialRender() {
      require(['domReady', 'model-application-mobile'], function (domReady, app) {
        $.mobile.defaultPageTransition = app.get("defaultTransition");
        domReady(function () {
          $.mobile.changePage($.mobile.path.parseLocation().pathname, {
            changeHash: false,
            reloadPage: true,
            transition: 'fade'
          });
          $(document).on('pageshow', function () {
            $('#temp').remove();
          });
        });
      });
    }

    function start() {
      // AJAX Default Options
      $.ajaxPrefilter(function (options, originalOptions, jqXHR) {
        jqXHR.setRequestHeader('X-Blink-Config', JSON.stringify(window.BMP.siteVars));
      });

      require(['model-application-mobile'], function (app) {
        app.once('initialize', function () {
          if (navigator.onLine) {
            app.populate().done(function () {
              initialRender();
            });
          } else {
            app.set({_id: window.BMP.siteVars.answerSpace}).fetch({
              success: function (model, response, options) {
                initialRender();
              },
              error: function (model, response, options) {
                app.populate().done(function () {
                  initialRender();
                });
              }
            });
          }
        });

        // Now process the app start

      });
    }

    // Delay the app for Cordova
    function init() {
      if (window.BMP.isBlinkGap === true) {
        if (cordova.available === true) {
          start();
        } else {
          // Poll
          window.setTimeout(init(), 1000);
        }
      } else {
        start();
      }
    }

    init();
  }
);}());